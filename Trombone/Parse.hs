{-# LANGUAGE OverloadedStrings #-}
module Trombone.Parse 
    ( parseRoutes
    ) where

import Control.Applicative
import Control.Monad                                          ( liftM, mzero )
import Data.Aeson
import Data.Attoparsec.Text
import Data.List                                              ( foldl' )
import Data.Monoid                                            ( (<>) )
import Data.Text                                              ( Text )
import Data.Text.Encoding
import Network.HTTP.Types.Method
import Trombone.Db.Parse
import Trombone.Db.Reflection
import Trombone.Db.Template
import Trombone.Pipeline
import Trombone.Pipeline.Json
import Trombone.Response
import Trombone.Route
import Trombone.RoutePattern

import qualified Data.Attoparsec.Text                         as PT
import qualified Data.ByteString.Lazy.Char8                   as L8
import qualified Data.Text                                    as T

-- | Parse an HTTP method.
method :: Parser Method
method = match "GET"
     <|> match "POST"
     <|> match "PUT"
     <|> match "PATCH"
     <|> match "DELETE"
     <|> match "OPTIONS"  
  where
    match = (>>) <$> string 
                <*> (return . encodeUtf8)

-- | Match a single alphanumeric character.
alphaNum :: Parser Char
alphaNum = letter <|> digit

-- | Accept strings made up strictly of alphanumeric characters together
-- with a subset of the special ascii characters.
literal :: Parser Text
literal = T.pack <$> many1 (alphaNum <|> satisfy (inClass "-_!~"))

-- | A comma-separated list of items.
elements :: Parser [Text]
elements = sepBy cell $ char ',' 

-- | A list item.
cell :: Parser Text
cell = skipSpace *> PT.takeWhile (notInClass ",\n\r) ") <* skipSpace

-- | Parse a route pattern.
uri :: Parser RoutePattern
uri = optional slsh *> liftM RoutePattern (item `sepBy` slsh) <* optional slsh
  where
    item = variable <|> atom
    slsh = char '/'

-- | Parse a uri variable segment.
variable :: Parser RouteSegment
variable = char ':' >> liftM Variable literal 

-- | Parse a textual uri segment.
atom :: Parser RouteSegment
atom = liftM Atom literal

-- | Parse a single line of input generated by the preprocessor.
line :: Parser [Route]
line = skipSpace *> route 

route :: Parser [Route]
route = return <$> 
    ( Route <$> method <* skipSpace
            <*> uri    <* skipSpace
            <*> action )

-- | Any of the valid route action types.
action :: Parser RouteAction
action = sqlRoute
     <|> pipelineRoute
     <|> inlineRoute
     <|> staticRoute
     <|> nodeJsRoute

-- | A database query route.
sqlRoute :: Parser RouteAction
sqlRoute = sqlNoResult 
       <|> sqlItem
       <|> sqlItemOk
       <|> sqlCollection
       <|> sqlLastInsert
       <|> sqlCount

resultFromTemplate :: DbResult -> DbTemplate -> Parser RouteAction
resultFromTemplate res = return . RouteSql . DbQuery res 

-- | An optional list of field names used for db routes.
hints :: Parser [Text]
hints = char '(' *> elements <* char ')'

-- | A PostgreSQL route of type that returns no result.
sqlNoResult :: Parser RouteAction
sqlNoResult = string "--" >> skipSpace *> takeText 
           >>= resultFromTemplate NoResult . parseDbTemplate

-- | A PostgreSQL route of type that returns a single item.
sqlItem :: Parser RouteAction
sqlItem = string "~>" >> sqlres Item

-- | A PostgreSQL route of type that returns a single item with an 'Ok' status 
-- message.
sqlItemOk :: Parser RouteAction
sqlItemOk = string "->" >> sqlres ItemOk

-- | A PostgreSQL route of type that returns a collection.
sqlCollection :: Parser RouteAction
sqlCollection = string ">>" >> sqlres Collection

-- | A PostgreSQL route of type that returns the last inserted id.
sqlLastInsert :: Parser RouteAction
sqlLastInsert = string "<>" >> 
    skipSpace *> params <|> inspect 
  where
    params = hints >>= \[table, s] -> 
        liftM (RouteSql . DbQuery (LastInsert table s) 
                        . parseDbTemplate) 
                        $ takeText
    inspect = takeText >>= \q -> 
        let tpl = parseDbTemplate q in
        case probeTemplate tpl of
            (Just tbl, _) -> resultFromTemplate (LastInsert tbl "id") tpl
            _             -> error 
                    "Unable to infer table name from SQL statement."

-- | A PostgreSQL route of type that returns a row count.
sqlCount :: Parser RouteAction
sqlCount = string "><" >> skipSpace *> takeText
        >>= resultFromTemplate Count . parseDbTemplate 

sqlres :: ([Text] -> DbResult) -> Parser RouteAction
sqlres c = skipSpace *> params <|> inspect c
  where
    params = hints >>= \h -> takeText 
                   >>= resultFromTemplate (c h) . parseDbTemplate 
    inspect res = takeText >>= \q -> 
        let tpl = parseDbTemplate q in
        case probeTemplate tpl of
            (Just tbl, Just ["*"]) -> resultFromTemplate (res ["*", tbl]) tpl
            (_, Just cs)           -> resultFromTemplate (res cs) tpl
            _                      -> error 
                    "Unable to extract column names from SQL template. \
                    \An explicit parameter list is required in the route configuration."

-- | Parse a pipeline route.
pipelineRoute :: Parser RouteAction
pipelineRoute = applyAfter "||" RouteNodeJs 

-- | Parse an inlined pipeline route.
inlineRoute :: Parser RouteAction
inlineRoute = applyAfter "|>" f
  where
    f :: Text -> RouteAction
    f t = case pipe t of
        Left e  -> error $ "Error parsing pipeline: " ++ T.unpack t
        Right p -> RouteInline p
    pipe :: Text -> Either String Pipeline
    pipe = eitherDecode . L8.fromStrict . encodeUtf8 
 
-- | Parse a static route.
staticRoute :: Parser RouteAction
staticRoute = applyAfter "{..}" f
  where
    f :: Text -> RouteAction
    f t = case json t of
            Just v -> RouteStatic $ RouteResponse [] 200 v
            Nothing -> error 
                "Failed to parse JSON data in static route pattern."
    json :: Text -> Maybe Value
    json = decode . L8.fromStrict . encodeUtf8 

-- | Parse a node.js route.
nodeJsRoute :: Parser RouteAction
nodeJsRoute = liftM RouteNodeJs $ string "<js>" >> skipSpace *> takeText

applyAfter :: Text -> (Text -> r) -> Parser r
applyAfter symb f = liftM f $ string symb >> skipSpace *> takeText

-------------------------------------------------------------------------------
-- Preprocessing
-------------------------------------------------------------------------------

type Line = (Int, Text)

preprocess :: Text -> [Line]
preprocess = concatMap expandDry . collapse . zip [1..] . fmap uncomment . T.lines 

-- | Strip out everything on a line including and after its first # character.
uncomment :: Text -> Text
uncomment = fst . T.breakOn "#" 

-- | Expand DRY-blocks to individual routes.
expandDry :: Line -> [Line]
expandDry (ln, t) | T.isPrefixOf "DRY" t = map ((,) ln) $ (ex ln) (T.lines t)
                  | otherwise            = [(ln, t)]
  where
    ex :: Int -> [Text] -> [Text]
    ex ln (x:y:_) = f (T.splitOn ";" <$> T.stripPrefix "{" y) (T.stripPrefix "DRY" x)
    ex ln _ = error $ "Malformed dry-block on line " ++ show ln ++ "."
    f (Just xs) (Just t) = filter (not . T.null . T.strip) $ fmap (inject t) xs
    f _ _ = ex ln []
 
inject :: Text -> Text -> Text
inject template = T.intercalate " " . concatMap g . T.splitOn " " . T.strip 
  where 
    g x | x `elem` arrows = [x, template]
        | otherwise  = [x]
    arrows = ["<js>", "{..}", "|>", "||", "><", ">>", "->", "~>", "<>", "--"]

-- | Canonicalize source input to a format with exactly one route pattern per
-- list entry.
collapse :: [Line] -> [Line]
collapse ls = 
    let (x, xs) = foldl' f ((1, ""), []) ls in filter notNull $ reverse (x:xs)
  where
    notNull = not . T.null . T.strip . snd 

f :: (Line, [Line]) -> Line -> (Line, [Line])
f ((m, x), xs) (n, a) | T.null a || ' ' == T.head a = ((m, " " `coalesce` a), xs)
                      | T.head a `elem` "{}" = ((m, T.snoc "\n" (T.head a) `coalesce` T.tail a), xs)
                      | otherwise       = ((n, T.strip a), (m, x):xs)
  where coalesce a b  | T.null x || "\n" `T.isSuffixOf` x = x      <> T.strip b
                      | otherwise                        = x <> a <> T.strip b
 
-------------------------------------------------------------------------------
-- Parsing
-------------------------------------------------------------------------------

parseRoutes :: Text -> [Route]
parseRoutes = concatMap (ps <$> parseOnly line . snd <*> id) . preprocess 
  where
    ps (Right r) _ = r
    ps (Left  e) (n, line) = error $ "Invalid route format on line " 
                           ++ show n ++ ": " ++ T.unpack line
    
